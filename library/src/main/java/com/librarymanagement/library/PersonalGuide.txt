1. First Create the neat folder structure.
2. Create the entity Classes
3. Ceate Jpa repositories for each enitity.

4. What is this exaclty in Author.java "@OneToMany(mappedBy = "author", cascade = CascadeType.ALL, orphanRemoval = true)"
Ans:-
     @OneToMany(mappedBy = "author", cascade = CascadeType.ALL, orphanRemoval = true)
     This is usually placed inside the Author entity to represent the relationship between an Author and their Books.
     1. @OneToMany
     Declares that one Author can have many Books.
     This is the "parent side" of a one-to-many relationship.
     2. mappedBy = "author"
     Tells JPA which field in the Book entity owns the relationship.
     In Book, you would have something like:
     @ManyToOne
     @JoinColumn(name = "author_id")
     private Author author;
     That means the Book table will have the foreign key (author_id) column.
     mappedBy just says: "Don’t create another column in the Author table, the relationship is already managed in Book."
     ✅ Importance: Prevents duplicate foreign key columns and makes the Book entity the owning side.
     3. cascade = CascadeType.ALL
     Means all operations on the Author should cascade to its Books.
     For example:
     If you save an Author with its list of Books → all Books are saved automatically.
     If you delete an Author → all related Books are deleted too.
     If you update the Author → its Books get updated.
     ✅ Importance: Makes handling parent-child entities much easier, no need to manually save/delete Books when you save/delete an Author.
     4. orphanRemoval = true
     If you remove a Book from the Author’s collection (author.getBooks().remove(book)), then JPA will delete that Book from the database automatically.
     Example:
     author.getBooks().remove(book); // removes from Set
     With orphanRemoval = true → The book row is deleted in DB.
     Without it → Only removed from Java object, but still remains in DB.
     ✅ Importance: Keeps DB in sync with Java objects, prevents "orphan" rows.
     Putting it together
     @Entity
     public class Author {
         @Id
         private Long authorId;

         @OneToMany(mappedBy = "author", cascade = CascadeType.ALL, orphanRemoval = true)
         private Set<Book> books = new HashSet<>();
     }
     One Author → Many Books
     Author does not store foreign key, Book does
     Saves/deletes cascade
     Orphans removed

5. Owner vs inverse side of the relationship?
6. Why use these DTOs? Why are there types again; request and response?
DTOs (Data Transfer Objects) are used to separate the internal entity models from the data that flows in and out of the API, ensuring security,
maintainability, and clarity. We use different types—request DTOs for accepting and validating data coming from the client,
and response DTOs for shaping and returning only the necessary information back to the client. This prevents overexposing internal fields,
allows flexibility in how data is presented, and makes the API more robust against changes in the underlying entity structure.
Like here, when we are adding a book the requestdto doesn't contain id or Author object, it contains author id. This service checks the availabilty of the author
and inserts the object into the model. and while saving to db, the id is auto generated and returned by thr responseDto.

7. even though I have Author author but the db book has author_id column??
Even though your Java entity has private Author author, JPA/Hibernate maps relationships via foreign keys.
It doesn’t put the entire Author object in the books table—it only stores a reference (the author_id).

8. Difference between patch and put request??
PUT rplaces the entire record with the new incmoing record. patch updates only the required fields.

Enitity-> Respository-> Service-> Controller

9. Why int doesnt need NotNull validation but Integer does??
In Java, primitive types like `int`, `double`, `boolean`, etc., **cannot be null** by design—they always have a default value
 (for example, `int` defaults to `0`). Because of this, annotations like `@NotNull` have **no effect** on primitives: the field can never actually be null,
 so the validation is meaningless. To make `@NotNull` effective, you need to use the corresponding **wrapper class** (e.g., `Integer` for `int`, `Double` for `double`, `Boolean` for `boolean`).
 Wrapper classes are **objects**, so they can be null. When you annotate a field of type `Integer` with `@NotNull`, the validation framework (like Spring’s Bean Validation) can check whether the
 value is null at runtime and reject invalid inputs, enforcing proper data validation before the object is persisted or processed. This is particularly important in DTOs where the field value comes from external sources, such as JSON requests,
 because it allows you to prevent missing or incomplete data from entering your application.

10. When API endpoints are same they result in : Ambigous Mapping Exception






















































UNDERSTANDING SPRING SECURITY.
  -> THE ENTITIES CLASSES
  -> The Repository for members.
  -> The UserDetail class.
This userDetails is like an standard id card that the spring understands
So this "CustomerMemeberDetails" takes one Member and creates a standard id of UserDetails for it which is then used to authenticate the member by the spring.

The userDetails is a contract.
it represents the principal or currently logged in member. This way spring simply look at the id card (UserDetails) for verification purposes rather than the entity class.
For authentication: getUsername(), getPassword()
for authorization: Collection<? extends GrantedAuthority> getAuthorities() thi used. It returns the principal's permissions.
